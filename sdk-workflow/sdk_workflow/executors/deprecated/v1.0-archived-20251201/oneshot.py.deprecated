"""
Oneshot Executor - Single message execution with auto-escalation.
Implements Haiku-first strategy with automatic escalation to Sonnet
when quality checks fail.
Uses Claude Agent SDK for execution.
"""
from typing import Optional, List
from .base import BaseExecutor
from core.config import Config
from core.types import (
    ExecutionResult,
    ExecutionMode,
    TokenUsage,
    CostBreakdown,
)
from core.agent_client import (
    get_agent_client,
    run_oneshot_sync,
    extract_text_from_message,
    extract_tool_uses_from_message,
    sdk_usage_to_token_usage,
    extract_usage_from_message,
)
from claude_agent_sdk import ClaudeAgentOptions, AssistantMessage
class OneshotExecutor(BaseExecutor):
    """
    Single-shot executor with intelligent model routing.
    Strategy:
    1. Start with Haiku (cost-effective)
    2. Check response quality
    3. Auto-escalate to Sonnet if quality fails
    Quality Checks:
    - Response contains escalation markers ("I cannot", etc.)
    - Response is too short (< min_quality_length)
    - Response indicates uncertainty
    """
    def __init__(self, config: Optional[Config] = None, model: Optional[str] = None, cwd: Optional[str] = None, permission_mode: Optional[str] = None):
        """
        Initialize oneshot executor.
        Args:
            config: Configuration instance
            model: Override default model (skips auto-routing)
            cwd: Working directory for agent execution
        """
        super().__init__(config)
        self._agent_client = None
        self._model_override = model
        self._cwd = cwd
        self._permission_mode = permission_mode
        self._escalated = False
        # Accumulated usage across escalation attempts
        self._total_usage = TokenUsage()
        self._total_cost = CostBreakdown()
    def setup(self) -> None:
        """Initialize Claude Agent SDK client."""
        self._agent_client = get_agent_client()
        self._escalated = False
        self._total_usage = TokenUsage()
        self._total_cost = CostBreakdown()
    def execute(self, task: str, system_prompt: str = "") -> ExecutionResult:
        """
        Execute single-shot request with auto-escalation.
        Args:
            task: The task/prompt to execute
            system_prompt: Optional system prompt
        Returns:
            ExecutionResult from best attempt
        """
        self._start_timer()
        # Determine starting model
        if self._model_override:
            model = self._model_override
        else:
            model = self.config.routing.default_oneshot_model
        # First attempt with initial model
        result = self._execute_with_model(task, system_prompt, model)
        # Check if escalation needed (only if started with haiku)
        if (
            not self._model_override and
            model == "haiku" and
            self._needs_escalation(result.content)
        ):
            # Escalate to Sonnet
            self._escalated = True
            escalated_result = self._execute_with_model(
                task,
                system_prompt,
                self.config.routing.default_streaming_model
            )
            escalated_result.escalated = True
            return escalated_result
        return result
    def _execute_with_model(
        self,
        task: str,
        system_prompt: str,
        model: str
    ) -> ExecutionResult:
        """
        Execute request with specific model using Claude Agent SDK.
        Args:
            task: The task to execute
            system_prompt: System prompt
            model: Model alias or ID
        Returns:
            ExecutionResult from this attempt
        """
        model_config = self.config.resolve_model(model)
        return self._execute_with_agent_sdk(task, system_prompt, model_config)
    def _execute_with_agent_sdk(
        self,
        task: str,
        system_prompt: str,
        model_config
    ) -> ExecutionResult:
        """Execute using Claude Agent SDK."""
        # Create options for the query
        options = self._agent_client.create_options(
            model=model_config.model_id,
            system_prompt=system_prompt,
            max_turns=1,
            cwd=self._cwd,
        )
        # Run the query synchronously
        messages = run_oneshot_sync(prompt=task, options=options)
        # Extract from final message
        content = ""
        tool_uses = []
        usage = TokenUsage()
        stop_reason = None
        for message in messages:
            if isinstance(message, AssistantMessage):
                content += extract_text_from_message(message)
                tool_uses.extend(extract_tool_uses_from_message(message))
                sdk_usage = extract_usage_from_message(message)
                usage = sdk_usage_to_token_usage(sdk_usage)
                stop_reason = getattr(message, 'stop_reason', None)
        # Calculate cost
        cost = self._calculate_cost(usage, model_config.model_id)
        # Accumulate totals
        self._accumulate_usage(usage, cost)
        return ExecutionResult(
            content=content,
            usage=self._total_usage,
            cost=self._total_cost,
            model=model_config.model_id,
            mode=ExecutionMode.ONESHOT,
            stop_reason=stop_reason,
            tool_uses=tool_uses,
            duration_ms=self._get_duration_ms(),
            escalated=self._escalated,
        )
    def _needs_escalation(self, response: str) -> bool:
        """
        Check if response indicates need for model escalation.
        Escalation triggers:
        - Response contains uncertainty markers
        - Response is suspiciously short
        - Response admits inability
        Args:
            response: The model's response text
        Returns:
            True if escalation is recommended
        """
        # Check for escalation markers
        response_lower = response.lower()
        for marker in self.config.routing.escalation_markers:
            if marker.lower() in response_lower:
                return True
        # Check for minimum quality length
        if len(response.strip()) < self.config.routing.min_quality_length:
            return True
        return False
    def _accumulate_usage(self, usage: TokenUsage, cost: CostBreakdown) -> None:
        """Accumulate usage and cost across attempts."""
        self._total_usage.input_tokens += usage.input_tokens
        self._total_usage.output_tokens += usage.output_tokens
        self._total_usage.cache_read_tokens += usage.cache_read_tokens
        self._total_usage.cache_write_tokens += usage.cache_write_tokens
        self._total_cost.input_cost += cost.input_cost
        self._total_cost.output_cost += cost.output_cost
        self._total_cost.cache_read_cost += cost.cache_read_cost
        self._total_cost.cache_write_cost += cost.cache_write_cost
    def cleanup(self) -> None:
        """Release resources."""
        self._agent_client = None
        self._escalated = False
